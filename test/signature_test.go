// Copyright (c) 2011 The Go Authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//
//  * Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
//  * Redistributions in binary form must reproduce the above copyright
// 		notice, this list of conditions and the following disclaimer in
//		the documentation and/or other materials provided with the
//		distribution.
//  * Neither the name of Google Inc. nor the names of its contributors
// 		may be used to endorse or promote products derived from this
//		software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

package test

import (
	"crypto/rand"
	"crypto/sha256"
	"fmt"
	"io"
	"math/big"
	"testing"

	"github.com/NethermindEth/juno/pkg/crypto/signature"
	"github.com/NethermindEth/juno/pkg/crypto/weierstrass"
)

type zr struct{ io.Reader }

// Read replaces the contents of dst with zeros.
func (z *zr) Read(dst []byte) (n int, err error) {
	for i := range dst {
		dst[i] = 0
	}
	return len(dst), nil
}

var (
	curve      = weierstrass.Stark()
	zeroReader = &zr{}
)

// BenchmarkGenerateKey performs a benchmark for the key generation
// function signature.GenerateKey.
func BenchmarkGenerateKey(b *testing.B) {
	b.ReportAllocs()
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		if _, err := signature.GenerateKey(curve, rand.Reader); err != nil {
			b.Fatal(err)
		}
	}
}

// BenchmarkSign performs a benchmark for signing messages using a
// generated private key.
func BenchmarkSign(b *testing.B) {
	pvt, err := signature.GenerateKey(curve, rand.Reader)
	if err != nil {
		b.Fatal(err)
	}
	hashed := []byte("testing")

	b.ReportAllocs()
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		sig, err := signature.SignASN1(rand.Reader, pvt, hashed)
		if err != nil {
			b.Fatal(err)
		}
		// Prevent the compiler from optimizing out the operation.
		hashed[0] = sig[0]
	}
}

// BenchmarkVerify performs a benchmark on verifying signatures on
// signed messages.
func BenchmarkVerify(b *testing.B) {
	pvt, err := signature.GenerateKey(curve, rand.Reader)
	if err != nil {
		b.Fatal(err)
	}
	hashed := []byte("testing")
	r, s, err := signature.Sign(rand.Reader, pvt, hashed)
	if err != nil {
		b.Fatal(err)
	}

	b.ReportAllocs()
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		if !signature.Verify(&pvt.PublicKey, hashed, r, s) {
			b.Fatal("verify failed")
		}
	}
}

// Example showcases the use of the signature package in the
// autogenerated documentation.
func Example() {
	privateKey, err := signature.GenerateKey(weierstrass.Stark(), rand.Reader)
	if err != nil {
		panic(err)
	}

	msg := "Hello, World!"
	hash := sha256.Sum256([]byte(msg))

	sig, err := signature.SignASN1(rand.Reader, privateKey, hash[:])
	if err != nil {
		panic(err)
	}
	fmt.Printf("signature: %x\n", sig)

	valid := signature.VerifyASN1(&privateKey.PublicKey, hash[:], sig)
	fmt.Println("signature verified:", valid)
}

// TestKeyGeneration tests the validity of the public keys generated
// from the key generation process.
func TestKeyGeneration(t *testing.T) {
	pvt, err := signature.GenerateKey(curve, rand.Reader)
	if err != nil {
		t.Fatal(err)
	}
	if !curve.IsOnCurve(pvt.PublicKey.X, pvt.PublicKey.Y) {
		t.Errorf("public key invalid: %s", err)
	}
}

// TestSignAndVerify tests the ability to sign and verify messages.
func TestSignAndVerify(t *testing.T) {
	pvt, err := signature.GenerateKey(curve, rand.Reader)
	if err != nil {
		t.Error("failed to generate key")
	}

	hashed := []byte("testing")
	r, s, err := signature.Sign(rand.Reader, pvt, hashed)
	if err != nil {
		t.Errorf("error signing: %s", err)
		return
	}

	if !signature.Verify(&pvt.PublicKey, hashed, r, s) {
		t.Error("failed to verify signature")
	}

	hashed[0] ^= 0xff // Scramble message.
	if signature.Verify(&pvt.PublicKey, hashed, r, s) {
		t.Error("signature.Verify always returns true")
	}
}

// TestNonceSafety checks for critical security vulnerabilities around
// how the nonce is used in ECDSA.
func TestNonceSafety(t *testing.T) {
	pvt, err := signature.GenerateKey(curve, rand.Reader)
	if err != nil {
		t.Error("failed to generate key")
	}

	hashed := []byte("testing")
	r0, s0, err := signature.Sign(zeroReader, pvt, hashed)
	if err != nil {
		t.Errorf("error signing: %s", err)
		return
	}

	hashed = []byte("testing...")
	r1, s1, err := signature.Sign(zeroReader, pvt, hashed)
	if err != nil {
		t.Errorf("error signing: %s", err)
		return
	}

	if s0.Cmp(s1) == 0 {
		t.Error("produced the same signatures on two distinct messages")
	}

	if r0.Cmp(r1) == 0 {
		t.Error("nonce reuse detected")
	}
}

// TestIndcca tests for the IND-CCA (indistinguishability under chosen
// ciphertext attack). See the following for a detailed explanation:
// https://crypto.stackexchange.com/questions/26689/easy-explanation-of-ind-security-notions.
func TestIndcca(t *testing.T) {
	pvt, err := signature.GenerateKey(curve, rand.Reader)
	if err != nil {
		t.Errorf("failed to generate key")
	}

	hashed := []byte("testing")
	r0, s0, err := signature.Sign(rand.Reader, pvt, hashed)
	if err != nil {
		t.Errorf("error signing: %s", err)
		return
	}

	hashed = []byte("testing...")
	r1, s1, err := signature.Sign(rand.Reader, pvt, hashed)
	if err != nil {
		t.Errorf("error signing: %s", err)
		return
	}

	if s0.Cmp(s1) == 0 {
		t.Error("produced the same signatures on two distinct messages")
	}

	if r0.Cmp(r1) == 0 {
		t.Error("nonce reuse detected")
	}
}

// TestNegativeInputs checks whether bogus inputs are invalidated i.e. a
// value for r larger than any defined by any of the curves in the
// weierstrass and elliptic packages.
func TestNegativeInputs(t *testing.T) {
	pvt, err := signature.GenerateKey(curve, rand.Reader)
	if err != nil {
		t.Error("failed to generate key")
	}

	var hash [32]byte
	r := new(big.Int).SetInt64(1)
	r.Lsh(r, 550 /* larger than any supported curve */)
	r.Neg(r)

	if signature.Verify(&pvt.PublicKey, hash[:], r, r) {
		t.Error("bogus signature accepted")
	}
}

// TestZeroHashSignature tests whether signing and verification can be
// performed on a message that consists of an array of all zero bytes.
func TestZeroHashSignature(t *testing.T) {
	pvt, err := signature.GenerateKey(curve, rand.Reader)
	if err != nil {
		t.Error("failed to generate key")
	}

	hash := make([]byte, 64)
	r, s, err := signature.Sign(rand.Reader, pvt, hash)
	if err != nil {
		t.Errorf("error signing: %s", err)
		return
	}

	if !signature.Verify(&pvt.PublicKey, hash, r, s) {
		t.Errorf("failed to verify message with a zeroed byte array for %T", curve)
	}
}
